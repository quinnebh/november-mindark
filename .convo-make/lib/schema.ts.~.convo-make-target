> define
__makeRoot="../.."
__makeFile="make.convo"
__makeOut="lib/schema.ts"
__model="gpt-5"

> system
You are generating content that will be directly written to "lib/schema.ts".
DO NOT include a preamble or postamble.

Always respond with the full content for "lib/schema.ts", even if you are making an
small or incremental update.

> appendUser
<app-description>
## theMindArk.AI Landing Page Overview

Exit Strategy Echo is a modern, luxurious, glassmorphic landing experience for theMindArk.AI. It prioritizes bold hero storytelling with immersive video, precision data visualizations that animate into view, and a minimal, high-contrast dark interface with subtle brand accents. Content is organized into three core sections: a cinematic Hero, animated Metrics/Graphs, and a split Storytelling section with video-led narrative and supporting visuals.

The site is built as a statically generated marketing page (NextJS pages directory) using React, Tailwind v4, and lucide-react for crisp iconography. Brand color #752E4F is used sparingly for premium emphasis and primary CTAs.


## Features

- Cinematic hero with text overlaying a right-aligned video
  - Right 2/3 video canvas using /videos/hero.mp4
  - Headline and subcopy float over the video with readable gradients and glass layers
  - “Square with a circle inside” motif referenced as a geometric accent and video cue

- Animated metrics and graphs
  - Values animate smoothly from 0 to their final values upon entering the viewport
  - Graph backgrounds harmonize with the dark, glassmorphic theme
  - Subtle brand-accent borders for highlighted cards without overusing the brand color

- Split narrative section with media-led storytelling
  - Left third: autoplaying, muted, looped video panel (placeholder-ready)
  - Right two thirds: layered images, captions, and short narrative text blocks
  - Recreated supporting visuals using glass cards, depth, and minimal iconography

- Premium visual style
  - Dark mode by default with soft gradients and sharp, minimal rounding
  - Glassmorphism: layered translucent surfaces with backdrop blur (xs–xl)
  - Float micro-animations on geometric accents
  - Shimmer effect on CTAs and image placeholders

- Responsive and accessible
  - Mobile-first responsive layout; flex-based stacking to avoid horizontal overflow
  - Legible contrast over video using gradient overlays and glass background layers
  - Reduced motion setting respected where possible for animations

- Performance and delivery
  - Static Site Generation (SSG) with NextJS pages (no SSR)
  - Lightweight dependencies and optimized media loading behavior
  - Lazy loading of non-critical imagery

- Developer experience
  - Tailwind v4 for rapid, consistent styling
  - lucide-react for lightweight iconography
  - Named exports for components; NextJS page defaults for routes
  - Clear section anchors and linkable routes


## Visual Identity and Styling

- Theme: Modern, luxurious, minimalistic, dark
- Primary brand color: #752E4F (used sparingly for primary CTAs and thin borders on key highlight elements)
- Backgrounds: Deep dark scales (50–900) with layered gradients for depth
- Glass surfaces: Translucent cards with backdrop blur and subtle inner shadows
- Typography:
  - Hero headline uses gradient text, oversized display style (72px desktop / 48px mobile)
  - Subtitles/captions use muted tones, careful letter spacing, and medium weight
- Motion: Gentle float for geometric accents; counters/graphs animate in; shimmer on hover for interactive elements


## Information Architecture and Routes

- Home: /
  - A single-page experience with anchor-based internal navigation

- Sections (with anchors):
  - Hero: /#hero
    - Cinematic first impression with bold value proposition. Right 2/3 video, text overlays, and a primary CTA.

  - SectionTwo (Metrics & Graphs): /#section-two
    - Animated KPIs and mini-graphs. Values count up from zero; graph backgrounds match dark-glass aesthetic.

  - SectionThree (Story & Solutions): /#section-three
    - Left third video, right two thirds with layered images and explanatory text. Recreates the supporting visuals closely within the dark, glass style.


## Section Details

### Hero (/#hero)
- Purpose:
  - Immediately communicate theMindArk.AI value with a high-contrast, cinematic look.
- Layout:
  - Left third: concise headline, subcopy, and a single primary CTA.
  - Right two thirds: embedded video surface using /videos/hero.mp4.
  - Text is intentionally layered over the video using a glassmorphic panel and a soft left-to-right gradient for readability.
- Visual Notes:
  - The “square with a circle inside” motif appears as a geometric accent to signal the video surface and reinforce brand geometry.
  - Hero headline uses gradient text and minimal letter spacing for a premium tone.
  - Brand color #752E4F appears as a thin border around the CTA or as the CTA background on hover for emphasis.
- Interaction:
  - Subtle float animations for geometric shapes.
  - Video is muted, looped, and optimized for performance; falls back gracefully.
- Accessibility:
  - High-contrast overlays ensure legibility.
  - Motion reduced if user prefers reduced motion.

### SectionTwo — Animated Metrics & Graphs (/#section-two)
- Purpose:
  - Prove value through data and credibility markers without overwhelming the user.
- Layout:
  - Flexible stacking layout using columns to preserve vertical flow on smaller devices.
  - KPI cards and compact graphs (bars/lines) arranged in 2–3 columns on desktop, collapsing to a single column on mobile.
- Animation:
  - Numeric values smoothly animate from 0 to their target numbers when they scroll into view.
  - Graph bars/lines animate from baseline 0 to their display values.
- Styling:
  - Graph backgrounds and cards use dark glass panels with backdrop blur, ensuring consistency across the page.
  - Subtle #752E4F accents for borders on highlighted KPIs; avoid large swaths of the brand color.
- Content:
  - Short labels and supporting captions; avoid long button labels in favor of icons when needed.

### SectionThree — Story & Solutions (/#section-three)
- Purpose:
  - Offer deeper narrative and conceptual clarity for the solution approach.
- Layout:
  - Left third: video area (muted, loop, poster-ready); mirrors hero’s glass container, but smaller and with its own gradient mask.
  - Right two thirds: a set of stacked glass cards featuring:
    - Supporting images (recreated to closely match source references)
    - Tight headlines and 1–2 sentence blurbs
    - Lightweight lucide-react icons where appropriate
- Visual Notes:
  - Images are placed on translucent cards with soft gradient glows and thin brand-accent borders when highlighted.
  - Use shimmer placeholders for lazy-loaded images.
- Interaction:
  - Subtle entrance transitions on scroll.
  - Hover states enhance depth without noisy motion.

### Navigation and CTAs
- Top Navigation:
  - Minimal, sticky, glassmorphic bar with subtle blur and gradient edge.
  - Anchor links: Hero, Metrics, Solutions.
- CTAs:
  - A single primary CTA in the hero; supporting CTAs below are icon-forward and compact.
  - Brand color is reserved for the primary CTA surface or as a thin border highlight.

### Footer
- Compact dark glass footer with muted text and small icons.
- Optional links to documentation or legal (if included later), maintaining minimalist footprint.


## Technical Notes

- Tech Stack:
  - React, NextJS (pages directory, static site generation), Tailwind v4, lucide-react
- Static Site Generation:
  - No server-side rendering; pages live under /pages with default exports per route.
- Layout:
  - Prefer stacking column layouts (flex) to avoid horizontal overflow.
  - Avoid fixed-width buttons; use icons when labels would be long.
- Hooks & Layout Modes:
  - The page can request no-margins mode for an edge-to-edge hero experience.
  - Fullscreen mode is available for future media-centric variations.
- Assets:
  - Hero video: /videos/hero.mp4
  - SectionThree video: placeholder-ready; designed to be swapped without layout shifts.
- Accessibility & Performance:
  - Respect reduced motion.
  - Optimize media loading and use lazy strategies for images.
  - Maintain strong color contrast over media and gradients.


## Summary of Sections with Routes

- Hero — route: /#hero
  - Cinematic hero with right-aligned video, text overlay, and primary CTA. Geometric motif underscores the video presence.

- SectionTwo (Animated Metrics & Graphs) — route: /#section-two
  - KPIs and graphs with animated values from zero; dark glass backgrounds for consistency; restrained brand accents.

- SectionThree (Story & Solutions) — route: /#section-three
  - Left third video with right two thirds of layered images and explanatory text. Recreated visuals styled with glassmorphism and subtle motion.
</app-description>

> appendUser
<coding-rules>
## Tech Stack
- ReactJS
- NextJS - pages directory and static site generation
- Tailwinds v4
- lucide-react - icons

## Layout
It is preferred to use stacking layouts using flex-box columns to avoid running out of horizontal
room. Avoid long names in buttons and prefer to use icons for buttons.

If buttons display text DO NOT give the button a static width.

## Static site generation
The frontend of the app uses static site generation so no server side rendering should be used. All
pages are stored in the pages directory and the NextJS app router is NOT used.

## Exports
Always use named exports unless explicitly told otherwise or required such as when creating NextJS
pages.


## Full screen screens
The `useFullPage` hook can be used to display a full screen page without the main navigation bar.

example:
``` tsx
import { useFullPage } from "@/lib/hooks";

function ExampleComponent(){

    useFullPage();

    return (
        <div></div>
    )
}
```

## Form Data
When creating forms store form data in a typed useState variable.

Zod schemas can be imported from `@/lib/schema` to validate types stored in the database.

Form state example:
``` tsx

interface NewsletterForm
{
    name:string
    email:string;
}
function ExampleComponent()
{
    const [newsletterData,setNewsletterData]=useState<NewsletterForm>({
        name:'',
        email:'',
    });

    return (
        <form>
            <input
                placeholder="Enter name"
                value={newsletterData.name}
                onChange={e=>setNewsletterData({...newsletterData,name:e.target.value})}
            />
            <input
                placeholder="Enter email"
                value={newsletterData.email}
                onChange={e=>setNewsletterData({...newsletterData,email:e.target.value})}
            />
        </form>
    )
}
```

## Pages
When creating NextJS pages export the page component as a default function with the function
name reflecting the name of the page.

Do not use the MainLayout component when creating a page. The Main Layout component will be
used by the top level App component.

Include the name of the page in the className of the root element of the page component using the
format of: "page--{PageComponentName}"

Example Page with a route of "/example":
``` tsx

export default function ExamplePage(){

    return (
        <div className="page--ExamplePage">
            Example page content
        <div>
    )
}
```

## Main Layout
The `MainLayout` component is used by the top level `App` component to render the main layout of the
app. By default the MainLayout should render pages in a centered column with a navigation bar.

### Main Layout Display modes
Pages can use the `useFullPage` and `useNoMargins` hooks to alter the way the page is displayed.
Implement display modes using css or class names, DO NOT change the render order or do anything
that would cause the page to be unmounted.

### Main Layout Fullscreen Mode
Pages can request to enter into fullscreen. Use the `useIsInFullPageMode` hook imported from 
`@/lib/hooks` to check if the page should be displayed in fullscreen mode. If useIsInFullPageMode
returns true hide the main navigation and any other UI other than the page content.

### Main Layout No Margins Mode
Pages can request to remove all page margins so that they can display content edge to edge. Use
the `useIsNoMarginMode` hook imported from `@/lib/hooks` to check if the page should be displayed
in no margins mode.


## Packages
This is the package.json file for the project. You can only use libraries based on the dependencies
of the package.json file.

``` json
{
  "dependencies": {
    "lucide-react": "^0.544.0",
    "markdown-it": "^14.1.0",
    "next": "15.5.4",
    "react": "19.1.0",
    "react-dom": "19.1.0",
    "rxjs": "^7.8.2",
    "uuid": "^13.0.0",
    "zod": "^4.1.11"
  },
  "devDependencies": {
    "@tailwindcss/postcss": "^4",
    "@types/node": "^20",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "tailwindcss": "^4",
    "typescript": "^5"
  }
}


```

## Standard Components
The following components can be used

### Logo
Displays the apps logo using an SVG

Import: `import { Logo } from "@/components/Logo";`
Props:
``` ts
interface LogoProps
{
    color?:string;
    /**
     * @default "w-8 h-8"
     */ 
    className?:string;
    size?:string|number;
}
```

## Utility Functions
The following utility functions can be imported from `@/lib/util`

``` ts
export type ClassNameValue = string | false | number | null | undefined | {
    [className: string]: any;
} | ClassNameValue[];

/**
 * Combines class names and ignores falsy values.
 */
export const cn=(...classNames:ClassNameValue[]):string=>;
```


## Hooks
React components can use the following hooks imported from `@/lib/hooks`

``` ts
/**
 * Hides common UI controls such as the main nav bar.
 * @param enabled If false the hook is disabled
 */
export const useFullPage=(enabled=true)=>;

/**
 * Removes all margins and paddings from the main layout while keeping the main navigation and
 * other shared UI elements
 * @param enabled If false the hook is disabled
 */
export const useNoMargins=(enabled=true)=>;

/**
 * Returns true if the page should be displayed in full screen
 */
export const useIsInFullPageMode=():boolean=>{
    const count=useSubject(fullPageSubject);
    return count>0;
}

/**
 * Returns true if the page should remove all margins
 */
export const useIsNoMarginMode=():boolean=>;
```
</coding-rules>

> appendUser
<editor-config>
root = true

[*]
indent_style = space
indent_size = 4
</editor-config>

> appendUser
Generate TypeScript types for common entities shared by the app.

> nop
//_END_MAKE_TARGET_INPUT_


> assistant
import { z } from "zod";

/**
 * Generic helpers
 */
export const zId = z.string().min(1, "id is required");
export type Id = z.infer<typeof zId>;

export const zNonEmpty = z.string().min(1, "Required");

export const zEmail = z
    .string()
    .trim()
    .toLowerCase()
    .email("Invalid email address");

export const zColorHex = z
    .string()
    .regex(/^#([0-9a-fA-F]{3}|[0-9a-fA-F]{6}|[0-9a-fA-F]{8})$/, "Invalid color hex");
export type ColorHex = z.infer<typeof zColorHex>;

/**
 * URLs and paths
 * - Allow on-site roots (/path) and absolute http(s) links.
 */
export const zHref = z
    .string()
    .trim()
    .refine(
        (v) =>
            v.startsWith("/") ||
            v.startsWith("http://") ||
            v.startsWith("https://") ||
            v.startsWith("mailto:") ||
            v.startsWith("tel:"),
        "Must be a path or a valid URL (/, http(s), mailto, tel)"
    );
export type Href = z.infer<typeof zHref>;

/**
 * Video paths for hero and showcases
 * Accepts on-site assets and absolute URLs
 */
export const zVideoPath = z
    .string()
    .trim()
    .refine(
        (v) =>
            v.startsWith("/videos/") ||
            v.startsWith("http://") ||
            v.startsWith("https://"),
        "Video should be served from /videos or a full URL"
    )
    .refine((v) => v.endsWith(".mp4") || v.endsWith(".webm"), "Video must be .mp4 or .webm");
export type VideoPath = z.infer<typeof zVideoPath>;

/**
 * Section anchors
 */
export const SectionIdEnum = z.enum([
    "hero",
    "features",
    "echo",
    "playbook",
    "metrics",
    "how-it-works",
    "cta",
    "faq",
    "footer",
]);
export type SectionId = z.infer<typeof SectionIdEnum>;

export const zAnchorHref = z.custom<`/#${SectionId}`>((val) => {
    if (typeof val !== "string") return false;
    if (!val.startsWith("/#")) return false;
    const id = val.slice(2) as SectionId;
    return SectionIdEnum.safeParse(id).success;
}, "Anchor href must match '/#section-id'");
export type AnchorHref = z.infer<typeof zAnchorHref>;

/**
 * CTA
 */
export const CtaStyleEnum = z.enum(["primary", "secondary", "link"]);
export type CtaStyle = z.infer<typeof CtaStyleEnum>;

export const zCTA = z.object({
    label: zNonEmpty.max(40),
    href: z.union([zHref, zAnchorHref]),
    style: CtaStyleEnum.default("primary"),
    /**
     * Optional icon name (lucide icon identifier) used by UI layer
     */
    icon: z.string().optional(),
    newTab: z.boolean().default(false),
    /**
     * Accessible description for screen readers
     */
    srLabel: z.string().optional(),
});
export type CTA = z.infer<typeof zCTA>;

/**
 * Media
 */
export const zVideoSource = z.object({
    src: zVideoPath,
    type: z.enum(["mp4", "webm"]).default("mp4"),
    poster: z
        .string()
        .trim()
        .optional(),
});
export type VideoSource = z.infer<typeof zVideoSource>;

/**
 * Hero content
 */
export const zHero = z.object({
    id: SectionIdEnum.default("hero"),
    headline: zNonEmpty.max(120),
    subheadline: zNonEmpty.max(240),
    primaryCta: zCTA,
    secondaryCta: zCTA.optional(),
    video: zVideoSource,
    /**
     * Visual options for overlays and theme
     */
    overlay: z
        .object({
            enabled: z.boolean().default(true),
            /**
             * Backdrop gradient opacity 0-1
             */
            gradientOpacity: z.number().min(0).max(1).default(0.35),
            blurPx: z.number().min(0).max(20).default(6),
        })
        .default({}),
    motif: z
        .object({
            /**
             * "square-with-circle" to reflect brand motif in hero container
             */
            type: z.enum(["square-with-circle"]).default("square-with-circle"),
            borderColor: zColorHex.optional(),
            borderOpacity: z.number().min(0).max(1).default(0.2),
            radius: z.number().min(0).max(24).default(8),
        })
        .default({}),
});
export type Hero = z.infer<typeof zHero>;

/**
 * Features Overview
 */
export const zFeature = z.object({
    id: zId.optional(),
    title: zNonEmpty.max(80),
    description: zNonEmpty.max(280),
    /**
     * Icon identifier (lucide icon name) - presentation-only
     */
    icon: z.string().optional(),
    /**
     * One supporting benefit tagline
     */
    benefit: z.string().max(140).optional(),
});
export type Feature = z.infer<typeof zFeature>;

export const zFeaturesSection = z.object({
    id: SectionIdEnum.default("features"),
    items: z.array(zFeature).min(1).max(6),
});
export type FeaturesSection = z.infer<typeof zFeaturesSection>;

/**
 * Echo (AI Assistant) specifics
 */
export const zEchoUseCase = z.object({
    prompt: zNonEmpty.max(160),
    /**
     * Optional short explanation of how Echo responds or why it matters
     */
    note: z.string().max(160).optional(),
});
export type EchoUseCase = z.infer<typeof zEchoUseCase>;

export const zEchoSection = z.object({
    id: SectionIdEnum.default("echo"),
    title: zNonEmpty.max(100).default("Echo (AI Assistant)"),
    description: zNonEmpty.max(320),
    useCases: z.array(zEchoUseCase).min(1).max(8),
});
export type EchoSection = z.infer<typeof zEchoSection>;

/**
 * Onboarding Playbook structure
 */
export const PlaybookHeadingEnum = z.enum([
    "Role Overview",
    "Core Responsibilities",
    "Daily/Weekly/Monthly Routines",
    "Key Systems and Access",
    "Processes and SOPs",
    "Stakeholders and Communication",
    "FAQs and Troubleshooting",
]);
export type PlaybookHeading = z.infer<typeof PlaybookHeadingEnum>;

export const zPlaybookEntry = z.object({
    heading: PlaybookHeadingEnum,
    /**
     * Markdown content for the entry
     */
    bodyMarkdown: zNonEmpty,
});
export type PlaybookEntry = z.infer<typeof zPlaybookEntry>;

export const zPlaybookSection = z.object({
    id: SectionIdEnum.default("playbook"),
    title: zNonEmpty.max(100).default("Onboarding Playbook"),
    description: zNonEmpty.max(320),
    outline: z.array(zPlaybookEntry).min(1),
});
export type PlaybookSection = z.infer<typeof zPlaybookSection>;

/**
 * Metrics & Impact
 */
export const EasingEnum = z.enum(["linear", "easeIn", "easeOut", "easeInOut"]);
export type Easing = z.infer<typeof EasingEnum>;

export const zMetric = z.object({
    id: zId.optional(),
    label: zNonEmpty.max(80),
    /**
     * Target numeric value to animate to
     */
    value: z.number().nonnegative(),
    /**
     * Unit label displayed near value (%, days, weeks, score)
     */
    unit: z.string().max(16).optional(),
    /**
     * Animation config
     */
    animate: z
        .object({
            durationMs: z.number().min(100).max(5000).default(1400),
            delayMs: z.number().min(0).max(2000).default(0),
            easing: EasingEnum.default("easeOut"),
        })
        .default({}),
});
export type Metric = z.infer<typeof zMetric>;

export const GraphBackgroundStyleEnum = z.enum(["glass-dark", "solid-dark"]);
export type GraphBackgroundStyle = z.infer<typeof GraphBackgroundStyleEnum>;

export const zMetricsSection = z.object({
    id: SectionIdEnum.default("metrics"),
    title: zNonEmpty.max(100).default("Metrics & Impact"),
    subtitle: z.string().max(200).optional(),
    metrics: z.array(zMetric).min(1).max(8),
    graphStyle: z
        .object({
            background: GraphBackgroundStyleEnum.default("glass-dark"),
            /**
             * Accent color used sparingly for highlights
             * Default brand: #752E4F
             */
            accent: zColorHex.default("#752E4F"),
            /**
             * Apply a thin border highlight around a primary chart
             */
            accentBorder: z.boolean().default(true),
        })
        .default({}),
});
export type MetricsSection = z.infer<typeof zMetricsSection>;

/**
 * How It Works (3 steps)
 */
export const zHowStep = z.object({
    step: z.number().int().min(1).max(9),
    title: zNonEmpty.max(80),
    description: zNonEmpty.max(200),
    icon: z.string().optional(),
});
export type HowStep = z.infer<typeof zHowStep>;

export const zHowItWorksSection = z.object({
    id: SectionIdEnum.default("how-it-works"),
    title: zNonEmpty.max(100).default("How It Works"),
    steps: z.array(zHowStep).min(3).max(6),
});
export type HowItWorksSection = z.infer<typeof zHowItWorksSection>;

/**
 * Call To Action section
 */
export const zCTASection = z.object({
    id: SectionIdEnum.default("cta"),
    title: zNonEmpty.max(120),
    primary: zCTA,
    secondary: zCTA.optional(),
    /**
     * Visual: emphasize brand color background for primary CTA
     */
    emphasizeBrand: z.boolean().default(true),
});
export type CTASection = z.infer<typeof zCTASection>;

/**
 * FAQ
 */
export const zFaqItem = z.object({
    q: zNonEmpty.max(140),
    a: zNonEmpty,
});
export type FaqItem = z.infer<typeof zFaqItem>;

export const zFaqSection = z.object({
    id: SectionIdEnum.default("faq"),
    items: z.array(zFaqItem).min(1),
});
export type FaqSection = z.infer<typeof zFaqSection>;

/**
 * Footer
 */
export const zFooterLink = z.object({
    label: zNonEmpty.max(48),
    href: zHref,
    external: z.boolean().default(false),
});
export type FooterLink = z.infer<typeof zFooterLink>;

export const zFooter = z.object({
    id: SectionIdEnum.default("footer"),
    links: z.array(zFooterLink).min(1),
    attribution: z.string().max(160).optional(),
});
export type Footer = z.infer<typeof zFooter>;

/**
 * Navigation
 */
export const zNavItem = z.object({
    label: zNonEmpty.max(32),
    href: z.union([zAnchorHref, zHref]),
});
export type NavItem = z.infer<typeof zNavItem>;

export const zNav = z.object({
    items: z.array(zNavItem).min(1),
});
export type Nav = z.infer<typeof zNav>;

/**
 * Site meta and config
 */
export const zSocialLink = z.object({
    network: z.enum(["x", "linkedin", "github", "website", "youtube", "facebook", "instagram"]),
    href: zHref,
});
export type SocialLink = z.infer<typeof zSocialLink>;

export const zSiteMeta = z.object({
    title: zNonEmpty.max(80).default("theMindArk.AI — Exit Strategy Echo"),
    description: zNonEmpty.max(200).default(
        "Capture what they know. Keep it working. Replicate departing employees as secure Echos and generate an onboarding playbook that lasts."
    ),
    ogImage: z.string().optional(),
});
export type SiteMeta = z.infer<typeof zSiteMeta>;

export const zSiteConfig = z.object({
    brandName: zNonEmpty.max(64).default("theMindArk.AI"),
    brandColor: zColorHex.default("#752E4F"),
    darkMode: z.boolean().default(true),
    nav: zNav,
    social: z.array(zSocialLink).default([]),
    meta: zSiteMeta.default({}),
});
export type SiteConfig = z.infer<typeof zSiteConfig>;

/**
 * Landing page composition
 * All sections included in a single-page layout.
 */
export const zLandingPage = z.object({
    route: z.literal("/").default("/"),
    hero: zHero,
    features: zFeaturesSection,
    echo: zEchoSection,
    playbook: zPlaybookSection,
    metrics: zMetricsSection,
    howItWorks: zHowItWorksSection,
    cta: zCTASection,
    faq: zFaqSection,
    footer: zFooter,
    config: zSiteConfig,
});
export type LandingPage = z.infer<typeof zLandingPage>;

/**
 * Forms
 */
export const zNewsletterForm = z.object({
    name: zNonEmpty.max(80),
    email: zEmail,
});
export type NewsletterForm = z.infer<typeof zNewsletterForm>;

export const zDemoRequestForm = z.object({
    name: zNonEmpty.max(80),
    email: zEmail,
    company: zNonEmpty.max(120),
    role: z.string().max(80).optional(),
    teamSize: z
        .number()
        .int()
        .min(1)
        .max(100000)
        .optional(),
    message: z.string().max(800).optional(),
    /**
     * Checkbox to accept privacy/terms if applicable
     */
    agreeToContact: z.boolean().default(true),
});
export type DemoRequestForm = z.infer<typeof zDemoRequestForm>;

/**
 * Utility: guards
 */
export const isAnchorHref = (value: unknown): value is AnchorHref =>
    zAnchorHref.safeParse(value).success;

export const isColorHex = (value: unknown): value is ColorHex =>
    zColorHex.safeParse(value).success;

> user
